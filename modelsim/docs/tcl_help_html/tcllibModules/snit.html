<! -- -*- tcl -*- doctools manpage
   -->
<html><head>
<title>snit - Snit </title>
</head>
<! -- Generated from file './modules/snit/snit.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2003, by William H. Duquette
   -->
<! -- CVS: $Id$ snit.n
   -->

<body>
<h1> snit(n) 0.92 snit &quot;Snit&quot;</h1>
<h2><a name="name">NAME</a></h2>
<p>
<p> snit - Snit's Not Incr Tcl





<h2><a name="synopsis">SYNOPSIS</a></h2>
<p>
package require <b>Tcl 8.4</b><br>
package require <b>snit ?0.92?</b><br>
<br><table border=1 width=100% cellspacing=0 cellpadding=0><tr            bgcolor=lightyellow><td bgcolor=lightyellow><table 0 width=100% cellspacing=0 cellpadding=0><tr valign=top ><td ><a href="#1"><b class='cmd'>$object</b> <i class='arg'>method</i> <i class='arg'>args...</i></a></td></tr>
<tr valign=top ><td ><a href="#2"><b class='cmd'>$object</b> <strong>configure</strong> ?<i class='arg'>option</i>? ?<i class='arg'>value</i>? ...</a></td></tr>
<tr valign=top ><td ><a href="#3"><b class='cmd'>$object</b> <strong>configurelist</strong> <i class='arg'>optionlist</i></a></td></tr>
<tr valign=top ><td ><a href="#4"><b class='cmd'>$object</b> <strong>cget</strong> <i class='arg'>option</i></a></td></tr>
<tr valign=top ><td ><a href="#5"><b class='cmd'>$object</b> <strong>destroy</strong></a></td></tr>
<tr valign=top ><td ><a href="#6"><b class='cmd'>$object</b> <strong>info type</strong></a></td></tr>
<tr valign=top ><td ><a href="#7"><b class='cmd'>$object</b> <strong>info vars</strong> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#8"><b class='cmd'>$object</b> <strong>info typevars</strong> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#9"><b class='cmd'>$object</b> <strong>info options</strong> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#10"><b class='cmd'>varname</b> <i class='arg'>name</i></a></td></tr>
<tr valign=top ><td ><a href="#11"><b class='cmd'>typevarname</b> <i class='arg'>name</i></a></td></tr>
<tr valign=top ><td ><a href="#12"><b class='cmd'>codename</b> <i class='arg'>name</i></a></td></tr>
<tr valign=top ><td ><a href="#13"><b class='cmd'>from</b> <i class='arg'>argvName</i> <i class='arg'>option</i> ?<i class='arg'>defvalue</i>?</a></td></tr>
<tr valign=top ><td ><a href="#14"><b class='cmd'>variable</b> <i class='arg'>name</i></a></td></tr>
<tr valign=top ><td ><a href="#15"><b class='cmd'>typevariable</b> <i class='arg'>name</i></a></td></tr>
<tr valign=top ><td ><a href="#16"><b class='cmd'>install</b> <i class='arg'>compName</i> <strong>using</strong> <i class='arg'>objType</i> <i class='arg'>objName</i> <i class='arg'>args...</i></a></td></tr>
<tr valign=top ><td ><a href="#17"><b class='cmd'>installhull</b> <strong>using</strong> <i class='arg'>widgetType</i> <i class='arg'>args...</i></a></td></tr>
<tr valign=top ><td ><a href="#18"><b class='cmd'>installhull</b> <i class='arg'>name</i></a></td></tr>
<tr valign=top ><td ><a href="#19"><b class='cmd'>snit::type</b> <i class='arg'>name</i> <i class='arg'>definition</i></a></td></tr>
<tr valign=top ><td ><a href="#20"><b class='cmd'>typevariable</b> <i class='arg'>name</i> ?<i class='arg'>value</i>?</a></td></tr>
<tr valign=top ><td ><a href="#21"><b class='cmd'>typemethod</b> <i class='arg'>name</i> <i class='arg'>arglist</i> <i class='arg'>body</i></a></td></tr>
<tr valign=top ><td ><a href="#22"><b class='cmd'>option</b> <i class='arg'>namespec</i> ?<i class='arg'>defaultValue</i>?</a></td></tr>
<tr valign=top ><td ><a href="#23"><b class='cmd'>variable</b> <i class='arg'>name</i> ?<i class='arg'>value</i>?</a></td></tr>
<tr valign=top ><td ><a href="#24"><b class='cmd'>method</b> <i class='arg'>name</i> <i class='arg'>arglist</i> <i class='arg'>body</i></a></td></tr>
<tr valign=top ><td ><a href="#25"><b class='cmd'>constructor</b> <i class='arg'>arglist</i> <i class='arg'>body</i></a></td></tr>
<tr valign=top ><td ><a href="#26"><b class='cmd'>destructor</b> <i class='arg'>body</i></a></td></tr>
<tr valign=top ><td ><a href="#27"><b class='cmd'>onconfigure</b> <i class='arg'>name</i> <i class='arg'>arglist</i> <i class='arg'>body</i></a></td></tr>
<tr valign=top ><td ><a href="#28"><b class='cmd'>oncget</b> <i class='arg'>name</i> <i class='arg'>body</i></a></td></tr>
<tr valign=top ><td ><a href="#29"><b class='cmd'>proc</b> <i class='arg'>name</i> <i class='arg'>args</i> <i class='arg'>body</i></a></td></tr>
<tr valign=top ><td ><a href="#30"><b class='cmd'>delegate</b> <strong>method</strong> <i class='arg'>name</i> <strong>to</strong> <i class='arg'>comp</i></a></td></tr>
<tr valign=top ><td ><a href="#31"><b class='cmd'>delegate</b> <strong>method</strong> <i class='arg'>name</i> <strong>to</strong> <i class='arg'>comp</i> <strong>as</strong> <i class='arg'>target</i></a></td></tr>
<tr valign=top ><td ><a href="#32"><b class='cmd'>delegate</b> <strong>method</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i></a></td></tr>
<tr valign=top ><td ><a href="#33"><b class='cmd'>delegate</b> <strong>method</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i> <strong>except</strong> <i class='arg'>exceptions</i></a></td></tr>
<tr valign=top ><td ><a href="#34"><b class='cmd'>delegate</b> <strong>option</strong> <i class='arg'>namespec</i> <strong>to</strong> <i class='arg'>comp</i></a></td></tr>
<tr valign=top ><td ><a href="#35"><b class='cmd'>delegate</b> <strong>option</strong> <i class='arg'>namespec</i> <strong>to</strong> <i class='arg'>comp</i> <strong>as</strong> <i class='arg'>target</i></a></td></tr>
<tr valign=top ><td ><a href="#36"><b class='cmd'>delegate</b> <strong>option</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i></a></td></tr>
<tr valign=top ><td ><a href="#37"><b class='cmd'>delegate</b> <strong>option</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i> <strong>except</strong> <i class='arg'>exceptions</i></a></td></tr>
<tr valign=top ><td ><a href="#38"><b class='cmd'>expose</b> <i class='arg'>comp</i></a></td></tr>
<tr valign=top ><td ><a href="#39"><b class='cmd'>expose</b> <i class='arg'>comp</i> <strong>as</strong> <i class='arg'>method</i></a></td></tr>
<tr valign=top ><td ><a href="#40"><b class='cmd'>snit::widget</b> <i class='arg'>name</i> <i class='arg'>definition</i></a></td></tr>
<tr valign=top ><td ><a href="#41"><b class='cmd'>widgetclass</b> <i class='arg'>name</i></a></td></tr>
<tr valign=top ><td ><a href="#42"><b class='cmd'>hulltype</b> <i class='arg'>type</i></a></td></tr>
<tr valign=top ><td ><a href="#43"><b class='cmd'>snit::widgetadaptor</b> <i class='arg'>name</i> <i class='arg'>definition</i></a></td></tr>
<tr valign=top ><td ><a href="#44"><b class='cmd'>$type</b> <i class='arg'>typemethod</i> <i class='arg'>args</i>...</a></td></tr>
<tr valign=top ><td ><a href="#45"><b class='cmd'>$type</b> <strong>create</strong> <i class='arg'>name</i> ?<i class='arg'>option</i> <i class='arg'>value</i> ...?</a></td></tr>
<tr valign=top ><td ><a href="#46"><b class='cmd'>$type</b> <strong>info typevars</strong> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#47"><b class='cmd'>$type</b> <strong>info instances</strong> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#48"><b class='cmd'>$type</b> <strong>destroy</strong></a></td></tr>
</table></td></tr></table>
<h2><a name="description">DESCRIPTION</a></h2>
<p>
<p>

Snit is yet another pure Tcl object and megawidget system.  It's
unique among Tcl object systems (so far as I know) in that it's a
system based not on inheritance but on delegation.  Object systems
based on inheritance only allow you to inherit from classes defined
using the same system, and that's a shame.  In Tcl, an object is
anything that acts like an object; it shouldn't matter how the object
was implemented.  I designed Snit to help me build applications out of
the materials at hand; thus, Snit is designed to be able to
incorporate and build on any object, whether it's a hand-coded object,
a <strong>Tk</strong> widget, an <strong>Incr Tcl</strong> object,
a <strong>BWidget</strong> or almost anything else.

<p>

This man page is intended to be a reference only; see the accompanying
<b class='cmd'>snitfaq</b> for a gentler, more tutorial introduction to Snit
concepts.


<h2><a name="reference">REFERENCE</a></h2>
<p>

<em>The Instance Command</em>
<p>

A Snit type or widget's <strong>create</strong> type method creates objects of
the type; each object has a unique name which is also a Tcl command.
This command is used to access the object's methods and data, and has
this form:

<p>

<dl>
<dt><a name="1"><b class='cmd'>$object</b> <i class='arg'>method</i> <i class='arg'>args...</i></a><dd>


The <i class='arg'>method</i> can be any of the standard instance methods defined
in the next section, or any instance method defined in the type
definition.

The subsequent <i class='arg'>args</i> depend on the specific <i class='arg'>method</i> chosen.

</dl>


<em>Standard Instance Methods</em>
<p>

In addition to any delegated or locally-defined instance methods in
the type's definition, all Snit objects will have at least the
following methods:

<p>

<dl>
<dt><a name="2"><b class='cmd'>$object</b> <strong>configure</strong> ?<i class='arg'>option</i>? ?<i class='arg'>value</i>? ...</a><dd>


Assigns new values to one or more options.  If called with one
argument, an <i class='arg'>option</i> name, returns a list describing the option,
as Tk widgets do; if called with no arguments, returns a list of lists
describing all options, as Tk widgets do.

<br><br>

Warning: This information will be available for delegated options only
if the component to which they are delegated has a <strong>configure</strong>
method that returns this same kind of information.


<br><br>
<dt><a name="3"><b class='cmd'>$object</b> <strong>configurelist</strong> <i class='arg'>optionlist</i></a><dd>


Like <strong>configure</strong>, but takes one argument, a list of options and
their values.  It's mostly useful in the type constructor, but can be
used anywhere.


<br><br>
<dt><a name="4"><b class='cmd'>$object</b> <strong>cget</strong> <i class='arg'>option</i></a><dd>


Returns the option's value.


<br><br>
<dt><a name="5"><b class='cmd'>$object</b> <strong>destroy</strong></a><dd>


Destroys the object, calling the <b class='cmd'>destructor</b> and freeing all
related memory.

<br><br>

<em>Note:</em>

The <strong>destroy</strong> method isn't defined for <b class='cmd'>snit::widget</b> or
<b class='cmd'>snit::widgetadaptor</b> objects; instances of these are destroyed by
calling the <strong>Tk</strong> <b class='cmd'>destroy</b> command, just as a normal
widget is.


<br><br>
<dt><a name="6"><b class='cmd'>$object</b> <strong>info type</strong></a><dd>


Returns the instance's type.


<br><br>
<dt><a name="7"><b class='cmd'>$object</b> <strong>info vars</strong> ?<i class='arg'>pattern</i>?</a><dd>


Returns a list of the object's instance variables (excluding Snit
internal variables).  The names are fully qualified.

<br><br>

If <i class='arg'>pattern</i> is given, it's used as a <b class='cmd'>string match</b>
pattern; only names which match the pattern are returned.


<br><br>
<dt><a name="8"><b class='cmd'>$object</b> <strong>info typevars</strong> ?<i class='arg'>pattern</i>?</a><dd>


Returns a list of the object's type's type variables (excluding Snit
internal variables).  The names are fully qualified.

<br><br>

If <i class='arg'>pattern</i> is given, it's used as a <b class='cmd'>string match</b>
pattern; only names which match the pattern are returned.


<br><br>
<dt><a name="9"><b class='cmd'>$object</b> <strong>info options</strong> ?<i class='arg'>pattern</i>?</a><dd>


Returns a list of the object's option names.  This always includes
local options and explicitly delegated options.  If unknown options
are delegated as well, and if the component to which they are
delegated responds to <b class='cmd'>$object configure</b> like Tk widgets do,
then the result will include all possible unknown options which could
be delegated to the component.

<br><br>

If <i class='arg'>pattern</i> is given, it's used as a <b class='cmd'>string match</b>
pattern; only names which match the pattern are returned.

<br><br>

Note that the return value might be different for different instances
of the same type, if component object types can vary from one instance
to another.

</dl>


<em>Commands for use in Object Code</em>
<p>

Snit defines the following commands for use in object code: type
methods, instance methods, constructors, destructors, onconfigure
handlers, oncget handlers, and procs.  They do not reside in the
::snit:: namespace; instead, they are created with the type, and are
directly available.


<dl>
<dt><a name="10"><b class='cmd'>varname</b> <i class='arg'>name</i></a><dd>


Given an instance variable name, returns the fully qualified name.
Use this if you're passing the variable to some other object, e.g., as
a <strong>-textvariable</strong> to a Tk label widget.


<br><br>
<dt><a name="11"><b class='cmd'>typevarname</b> <i class='arg'>name</i></a><dd>


Given an type variable name, returns the fully qualified name.  Use
this if you're passing the variable to some other object, e.g., as a
<strong>-textvariable</strong> to a Tk label widget.


<br><br>
<dt><a name="12"><b class='cmd'>codename</b> <i class='arg'>name</i></a><dd>


Given the name of a proc (but not a type or instance method), returns
the fully-qualified command name, suitable for passing as a callback.


<br><br>
<dt><a name="13"><b class='cmd'>from</b> <i class='arg'>argvName</i> <i class='arg'>option</i> ?<i class='arg'>defvalue</i>?</a><dd>


The <b class='cmd'>from</b> command plucks an option value from a list of options
and their values, such as is passed into a type's <b class='cmd'>constructor</b>.
<i class='arg'>argvName</i> must be the name of a variable containing such a list;
<i class='arg'>option</i> is the name of the specific option.

<br><br>

<b class='cmd'>from</b> looks for <i class='arg'>option</i> in the option list.  If it is found,
it and its value are removed from the list, and the value is returned.
If <i class='arg'>option</i> doesn't appear in the list, then the <i class='arg'>defvalue</i> is
returned.

If the option is a normal (undelegated) option, and <i class='arg'>defvalue</i> is
not specified, then the option's default value as specified in the
type definition will be returned instead.

       
<br><br>
<dt><a name="14"><b class='cmd'>variable</b> <i class='arg'>name</i></a><dd>


Normally, instance variables are defined in the type definition along
with the options, methods, and so forth; such instance variables are
automatically visible in all instance-specific code.  However,
instance code (e.g., method bodies) can declare such variables
explicitly using the <b class='cmd'>variable</b> command, if desired; or, instance
code can use the <b class='cmd'>variable</b> command to declare instance variables
that don't appear in the type definition.

<br><br>

It's generally best to define all instance variables in the type
definition, and omit declaring them in methods and so forth.

<br><br>

Note that this is not the same as the standard Tcl <b class='cmd'>::variable</b>
command.


<br><br>
<dt><a name="15"><b class='cmd'>typevariable</b> <i class='arg'>name</i></a><dd>


Normally, type variables are defined in the type definition, along
with the instance variables; such type variables are automatically
visible in all of the type's code.  However, type methods, instance
methods and so forth can use <b class='cmd'>typevariable</b> to declare type
variables explicitly, if desired; or, they can use <b class='cmd'>typevariable</b>
to declare type variables that don't appear in the type definition.

<br><br>

It's generally best to declare all type variables in the type
definition, and omit declaring them in methods, type methods, and so
forth.


<br><br>
<dt><a name="16"><b class='cmd'>install</b> <i class='arg'>compName</i> <strong>using</strong> <i class='arg'>objType</i> <i class='arg'>objName</i> <i class='arg'>args...</i></a><dd>


Creates a new object and installs it as a component, as described
under <em>Components and Delegation</em>.

If this is a <b class='cmd'>snit::type</b>, then the following two commands are
equivalent:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    install myComp using myObjType $self.myComp options...
</pre></td></tr></table></p>
<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    set myComp [myObjType $self.myComp options...]
</pre></td></tr></table></p>
<br><br>

Note that whichever method is used, <i class='arg'>compName</i> must still be
declared in the type definition using <b class='cmd'>variable</b>, or must be
referenced in at least one <b class='cmd'>delegate</b> statement.

If this is a <b class='cmd'>snit::widget</b> or <b class='cmd'>snit::widgetadaptor</b>, and if
options have been delegated to component <i class='arg'>compName</i>, then those
options will receive default values from the Tk option database.  Note
that it doesn't matter whether the component to be installed is a
widget or not.  See <em>The Tk Option Database</em> for more
information.


<br><br>
<dt><a name="17"><b class='cmd'>installhull</b> <strong>using</strong> <i class='arg'>widgetType</i> <i class='arg'>args...</i></a><dd>

<dt><a name="18"><b class='cmd'>installhull</b> <i class='arg'>name</i></a><dd>


The constructor of a <b class='cmd'>snit::widgetadaptor</b> must create a widget to
be the object's hull component; the widget is installed as the hull
component using this command.  Note that the installed widget's name
must be <strong>$win</strong>.

This command has two forms.

The first form specifies the <i class='arg'>widgetType</i> and the <i class='arg'>args...</i>
(that is, the hardcoded option list) to use in creating the hull.
Given this form, <b class='cmd'>installhull</b> creates the hull widget, and
initializes any options delegated to the hull from the Tk option
database.

In the second form, the hull widget has already been created; note
that its name must be &quot;$win&quot;.  In this case, the Tk option database is
<em>not</em> queried for any options delegated to the hull.

See <em>The Tk Option Database</em> for more information
about <b class='cmd'>snit::widgetadaptor</b>s and the option database.

The longer form is preferred; however, the shorter form allows the
programmer to adapt a widget created elsewhere, which is sometimes
useful.  For example, it can be used to adapt a &quot;page&quot; widget created
by a BWidgets tabbed notebook or pages manager widget.


<br><br>

The command which creates the hull widget usually just passes its
result to <b class='cmd'>installhull</b> as follows:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    installhull [frame $win options....]
</pre></td></tr></table></p>


</dl>


<em>Type and Widget Definitions</em>
<p>

<dl>

<dt><a name="19"><b class='cmd'>snit::type</b> <i class='arg'>name</i> <i class='arg'>definition</i></a><dd>


Defines a new abstract data type called <i class='arg'>name</i>.  If <i class='arg'>name</i> is
not a fully qualified command name, it is assumed to be a name in the
namespace in which the <b class='cmd'>snit::type</b> command appears (usually the
global namespace).  It returns the fully qualified type name.

<br><br>

The type name is then a command which is used to create objects of the
new type, along with other activities.

<br><br>

The <b class='cmd'>snit::type</b> <i class='arg'>definition</i> block is a script which may
contain the following definitions:

<br><br>
<br><br>
<dl>
<dt><a name="20"><b class='cmd'>typevariable</b> <i class='arg'>name</i> ?<i class='arg'>value</i>?</a><dd>


Defines a type variable with the specified <i class='arg'>name</i>, and optionally
the specified <i class='arg'>value</i>.  Type variables are shared by all instances
of the type.  This definition can be used to define array variables,
but cannot initialize their elements.

       
<br><br>
<dt><a name="21"><b class='cmd'>typemethod</b> <i class='arg'>name</i> <i class='arg'>arglist</i> <i class='arg'>body</i></a><dd>


Defines a type method with the specified name, argument list, and
body.

The variable <strong>type</strong> is automatically defined in the <i class='arg'>body</i> to
the type's fully-qualified name.

<br><br>

The <i class='arg'>arglist</i> is a normal Tcl argument list and may contain
default arguments and the <strong>args</strong> argument; however, it may not
contain the argument names <strong>type</strong>, <strong>self</strong>, <strong>selfns</strong>, or
<strong>win</strong>.

<br><br>

Type variables defined in the type <i class='arg'>definition</i> are automatically
visible in the <i class='arg'>body</i> of every type method.


<br><br>
<dt><a name="22"><b class='cmd'>option</b> <i class='arg'>namespec</i> ?<i class='arg'>defaultValue</i>?</a><dd>


Defines an option for instances of this type, and optionally gives it
an initial value.  (The option's value defaults to the empty string if
no initial value is specified.)

<br><br>

An option defined in this way is said to be <em>locally defined</em>.

<br><br>

The <i class='arg'>namespec</i> is a list defining the option's
name, resource name, and class name, e.g.:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    option {-font font Font} {Courier 12}
</pre></td></tr></table></p>
<br><br>

The option name must begin with a hyphen, and must not contain any
upper case letters. The resource name and class name are optional; if
not specified, the resource name defaults to the option name, minus
the hyphen, and the class name defaults to the resource name with the
first letter capitalized.  Thus, the following statement is equivalent
to the previous example:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    option -font {Courier 12}
</pre></td></tr></table></p>
<br><br>

See <em>The Tk Option Database</em> for more information about
resource and class names.

Options are normally set and retrieved using the standard
<strong>configure</strong> and <strong>cget</strong> instance methods.

<br><br>
<dt><a name="23"><b class='cmd'>variable</b> <i class='arg'>name</i> ?<i class='arg'>value</i>?</a><dd>


Defines an instance variable, a private variable associated with each
instance of this type, and optionally its initial value.  This
definition can be used to define array instance variables, but cannot
initialize their elements.

<br><br>

Note that the <b class='cmd'>delegate</b> statement implicitly defines an instance
variable for the named component.

       
<br><br>
<dt><a name="24"><b class='cmd'>method</b> <i class='arg'>name</i> <i class='arg'>arglist</i> <i class='arg'>body</i></a><dd>


Defines an instance method, a subcommand of each instance of this
type, with the specified name, argument list and body.

The <i class='arg'>arglist</i> is a standard Tcl argument list, and may contain
default values and the argument names.

The <i class='arg'>arglist</i> is a normal Tcl argument list and may contain
default arguments and the <strong>args</strong> argument.  In addition, the
method is implicitly passed the following arguments as well:

<strong>type</strong>, which contains the fully-qualified type name; <strong>self</strong>,
which contains the current instance command name; <strong>selfns</strong>, which
contains the name of the instance's private namespace; and <strong>win</strong>,
which contains the original instance name.

Consequently, the <i class='arg'>arglist</i> may not contain the argument names
<strong>type</strong>, <strong>self</strong>, <strong>selfns</strong>, or <strong>win</strong>.

<br><br>

An instance method defined in this way is said to be

<em>locally defined</em>.

<br><br>

Type and instance variables defined in the type <i class='arg'>definition</i> are
automatically visible in all instance methods.  If the type has
locally defined options, the <strong>options</strong> array is also visible.


<br><br>
<dt><a name="25"><b class='cmd'>constructor</b> <i class='arg'>arglist</i> <i class='arg'>body</i></a><dd>


The constructor definition specifies a <i class='arg'>body</i> of code to be
executed when a new instance is created.

<br><br>

The <i class='arg'>arglist</i> is a normal Tcl argument list and may contain
default arguments and the <strong>args</strong> argument.  As with methods, the
arguments <strong>type</strong>, <strong>self</strong>, <strong>selfns</strong>, and <strong>win</strong>, are
defined implicitly.

<br><br>

If the constructor is not defined, it defaults to this:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    constructor {args} {
        $self configurelist $args
    }
</pre></td></tr></table></p>
<br><br>

For standard Tk widget behavior (or to achieve the behavior of
previous versions of snit) the argument list should be the single name
<strong>args</strong>, as shown.


<br><br>
<dt><a name="26"><b class='cmd'>destructor</b> <i class='arg'>body</i></a><dd>


The destructor is used to code any actions which must take place when
an instance of the type is destroyed: typically, the destruction of
anything created in the constructor.

<br><br>

As with arguments, the parameters <strong>type</strong>, <strong>self</strong>,
<strong>selfns</strong>, and <strong>win</strong>, are defined implicitly.


<br><br>
<dt><a name="27"><b class='cmd'>onconfigure</b> <i class='arg'>name</i> <i class='arg'>arglist</i> <i class='arg'>body</i></a><dd>


Every locally-defined option has an <b class='cmd'>onconfigure</b> handler which is
called when the option is set to a new value by the <strong>configure</strong>
or <strong>configurelist</strong> instance method.

<br><br>

The <i class='arg'>arglist</i> may contain exactly one argument name. As with
methods, the arguments <strong>type</strong>, <strong>self</strong>, <strong>selfns</strong>, and
<strong>win</strong>, are defined implicitly.

<br><br>

If no explicit onconfigure handler is defined for an option, the
handler is defined as follows:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    onconfigure name {value} {
        set options(name) $value
    }
</pre></td></tr></table></p>
<br><br>

If an explicit onconfigure handler is defined, the options array will
be updated with the new value only if the handler so updates it.


<br><br>
<dt><a name="28"><b class='cmd'>oncget</b> <i class='arg'>name</i> <i class='arg'>body</i></a><dd>


Every locally-defined option has an <b class='cmd'>oncget</b> handler which is
called when the option's value is retrieved.

Although there is no explicit argument list, the arguments <strong>type</strong>,
<strong>self</strong>, <strong>selfns</strong>, and <strong>win</strong>, are defined implicitly, just
as they are for methods.

<br><br> 

The variables <strong>type</strong>, <strong>self</strong>, <strong>selfns</strong>, and <strong>win</strong> are
defined as usual in the handler's <i class='arg'>body</i>.  Whatever the handler
returns will be the return value of the call to the <strong>cget</strong>
instance method.

<br><br>

If no explicit oncget handler is defined for an option, the handler is
defined as follows:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    oncget name {
        return $options(name)
    }
</pre></td></tr></table></p>


<br><br>
<dt><a name="29"><b class='cmd'>proc</b> <i class='arg'>name</i> <i class='arg'>args</i> <i class='arg'>body</i></a><dd>


Defines a new Tcl procedure in the type's namespace.  The new proc
differs from a normal Tcl proc in that all type variables defined in
the type <i class='arg'>definition</i> are automatically visible.

<br><br>

Although they are not implicitly defined for procs, the argument names
<strong>type</strong>, <strong>self</strong>, <strong>selfns</strong>, and <strong>win</strong> should be
avoided.


<br><br>
<dt><a name="30"><b class='cmd'>delegate</b> <strong>method</strong> <i class='arg'>name</i> <strong>to</strong> <i class='arg'>comp</i></a><dd>

<dt><a name="31"><b class='cmd'>delegate</b> <strong>method</strong> <i class='arg'>name</i> <strong>to</strong> <i class='arg'>comp</i> <strong>as</strong> <i class='arg'>target</i></a><dd>

<dt><a name="32"><b class='cmd'>delegate</b> <strong>method</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i></a><dd>

<dt><a name="33"><b class='cmd'>delegate</b> <strong>method</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i> <strong>except</strong> <i class='arg'>exceptions</i></a><dd>



Delegates one or more instance methods to a component of the
object. When a method <i class='arg'>name</i> is explicitly stated, it will
automatically be delegated to the named component as though the method
were defined as follows:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    method name {args...} {
        $comp mymethod args...
    }
</pre></td></tr></table></p>
<br><br>

If desired, the delegated method may <i class='arg'>target</i> a method with a
different name by using the <strong>as</strong> clause; the <i class='arg'>target</i> may
also include arguments add to the beginning of the argument list.

<br><br>

The form &quot;delegate method *&quot; delegates all unknown method names to the
specified <i class='arg'>comp</i>onent.  The <strong>except</strong> clause can be used to
specify a list of <i class='arg'>exceptions</i>, i.e., method names that will not
be so delegated.

<br><br>

A method cannot be both locally defined and delegated.


<br><br>
<dt><a name="34"><b class='cmd'>delegate</b> <strong>option</strong> <i class='arg'>namespec</i> <strong>to</strong> <i class='arg'>comp</i></a><dd>

<dt><a name="35"><b class='cmd'>delegate</b> <strong>option</strong> <i class='arg'>namespec</i> <strong>to</strong> <i class='arg'>comp</i> <strong>as</strong> <i class='arg'>target</i></a><dd>


<dt><a name="36"><b class='cmd'>delegate</b> <strong>option</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i></a><dd>

<dt><a name="37"><b class='cmd'>delegate</b> <strong>option</strong> <strong>*</strong> <strong>to</strong> <i class='arg'>comp</i> <strong>except</strong> <i class='arg'>exceptions</i></a><dd>


Defines a delegated option; the <i class='arg'>namespec</i> is defined as for the
<b class='cmd'>option</b> statement.

When the <strong>configure</strong>, <strong>configurelist</strong>, or <strong>cget</strong>
instance method is used to set or retrieve the option's value, the
equivalent <strong>configure</strong> or <strong>cget</strong> command will be applied
to the component as though these <b class='cmd'>onconfigure</b> and <b class='cmd'>oncget</b>
handlers were defined, where <i class='arg'>name</i> is the option name from the
<i class='arg'>namespec</i>:

<br><br>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    onconfigure name {value} {
        $comp configure name $value
    }

    oncget name {
        return [$comp cget name]
    }
</pre></td></tr></table></p>
<br><br>

If the <strong>as</strong> clause is specified, then the <i class='arg'>target</i> option
name is used in place of <i class='arg'>name</i>.

<br><br>

The form &quot;delegate option *&quot; delegates all unknown method names to the
specified <i class='arg'>comp</i>.  The <strong>except</strong> clause can be used to
specify a list of <i class='arg'>exceptions</i>, i.e., option names that will not
be so delegated.

<br><br>

Warning: options can only be delegated to a component if it supports
the <strong>configure</strong> and <strong>cget</strong> instance methods.

<br><br>

Note that an option cannot be both locally defined and delegated.


<br><br>
<dt><a name="38"><b class='cmd'>expose</b> <i class='arg'>comp</i></a><dd>

<dt><a name="39"><b class='cmd'>expose</b> <i class='arg'>comp</i> <strong>as</strong> <i class='arg'>method</i></a><dd>


Exposes component <i class='arg'>comp</i> as a method of the type.  In the first
form, the method name is <i class='arg'>comp</i>; in the second form, the method
name is <i class='arg'>method</i>.

<br><br>

This differs from delegation in that it maps an instance method to the
component itself instead of to one of the component's methods.

<br><br>

Calling the new instance method is just like calling the component,
except that if the method is called with no arguments it returns the
component.

</dl>


<dt><a name="40"><b class='cmd'>snit::widget</b> <i class='arg'>name</i> <i class='arg'>definition</i></a><dd>


This command defines a Snit megawidget type with the specified

<i class='arg'>name</i>.

The <i class='arg'>definition</i> is defined identically to that for

<b class='cmd'>snit::type</b>. A <b class='cmd'>snit::widget</b> differs from a <b class='cmd'>snit::type</b>
in these ways:

<br><br>
<br><br>
<ul>
<li>

Every <b class='cmd'>snit::widget</b> instance has an automatically-created
component called <strong>hull</strong>, which is normally a Tk frame widget.
Other widgets created as part of the megawidget will be created within
this widget.

<br><br>

The hull component is initially created with the requested widget
name; then Snit does some magic, renaming the hull component and
installing its own instance command in its place.

The hull component's new name is saved in an instance variable called
<strong>hull</strong>.

<br><br>
<li>

The name of an instance must be valid Tk window name, and the parent
window must exist.

</ul>
<br><br>

A <b class='cmd'>snit::widget</b> definition can include any of statements allowed
in a <b class='cmd'>snit::type</b> definition, and may also include these as well:

<br><br>

<br><br>
<dl>

<dt><a name="41"><b class='cmd'>widgetclass</b> <i class='arg'>name</i></a><dd>


Sets the <b class='cmd'>snit::widget</b>'s widget class to <i class='arg'>name</i>, overriding
the default.  See <em>The Tk Option Database</em> for more
information.

<br><br>
<dt><a name="42"><b class='cmd'>hulltype</b> <i class='arg'>type</i></a><dd>


Determined the kind of widget used as the <b class='cmd'>snit::widget</b>'s hull.
The <i class='arg'>type</i> may be <b class='cmd'>frame</b> (the default) or <b class='cmd'>toplevel</b>.

</dl>

       
<dt><a name="43"><b class='cmd'>snit::widgetadaptor</b> <i class='arg'>name</i> <i class='arg'>definition</i></a><dd>


This command defines a Snit megawidget type with the specified name.
It differs from <b class='cmd'>snit::widget</b> in that the instance's <strong>hull</strong>
component is not created automatically, but is created in the
constructor and installed using the <b class='cmd'>installhull</b> command.  Once
the hull is installed, its instance command is renamed and replaced as
with normal <b class='cmd'>snit::widget</b>s.  The original command is again
accessible in the instance variable <strong>hull</strong>.

<br><br>

Note that in general it is not possible to change the
<em>widget class</em> of a <b class='cmd'>snit::widgetadaptor</b>'s hull widget.
See <em>The Tk Option Database</em> for information on how
<b class='cmd'>snit::widgetadaptor</b>s interact with the option database.

</dl>


<em>The Type Command</em>
<p>

A type or widget definition creates a type command, which is used to
create instances of the type.  The type command this form.

<p>
<dl>
<dt><a name="44"><b class='cmd'>$type</b> <i class='arg'>typemethod</i> <i class='arg'>args</i>...</a><dd>


The <i class='arg'>typemethod</i> can be any of the standard type methods defined
in the next section, or any type method defined in the type
definition.

The subsequent <i class='arg'>args</i> depend on the specific <i class='arg'>typemethod</i>
chosen.

</dl>


<em>Standard Type Methods</em>
<p>

In addition to any typemethods in the type's definition, all types and
widgets will have at least the following method:

<p>

<dl>

<dt><a name="45"><b class='cmd'>$type</b> <strong>create</strong> <i class='arg'>name</i> ?<i class='arg'>option</i> <i class='arg'>value</i> ...?</a><dd>


Creates a new instance of the type, giving it the specified <i class='arg'>name</i>
and calling the type's constructor.

<br><br>

For <b class='cmd'>snit::type</b>s, if <i class='arg'>name</i> is not a fully-qualified command
name, it is assumed to be a name in the namespace in which the call to
<b class='cmd'>snit::type</b> appears.  The method returns the fully-qualified
instance name.

<br><br>

For <b class='cmd'>snit::widget</b>s and <b class='cmd'>snit::widgetadaptor</b>s, <i class='arg'>name</i>
must be a valid widget name; the method returns the widget name.

<br><br>

So long as <i class='arg'>name</i> does not conflict with any defined type method
name, the <strong>create</strong> keyword may be omitted.

<br><br>

If the <i class='arg'>name</i> includes the string <strong>%AUTO%</strong>, it will be
replaced with the string <strong>$type$counter</strong> where <strong>$type</strong> is
the type name and <strong>$counter</strong> is a counter that increments each
time <strong>%AUTO%</strong> is used for this type.

<br><br>

By default, any arguments following the <i class='arg'>name</i> will be a list of
<i class='arg'>option</i> names and their <i class='arg'>value</i>s; however, a type's
constructor can specify a different argument list.


<br><br>
<dt><a name="46"><b class='cmd'>$type</b> <strong>info typevars</strong> ?<i class='arg'>pattern</i>?</a><dd>


Returns a list of the type's type variables (excluding Snit internal
variables); all variable names are fully-qualified.

<br><br>

If <i class='arg'>pattern</i> is given, it's used as a <b class='cmd'>string match</b>
pattern; only names which match the pattern are returned.


<br><br>
<dt><a name="47"><b class='cmd'>$type</b> <strong>info instances</strong> ?<i class='arg'>pattern</i>?</a><dd>


Returns a list of the type's instances.  For <b class='cmd'>snit::type</b>s, it
will be a list of fully-qualified instance names;
for <b class='cmd'>snit::widget</b>s, it will be a list of Tk widget names.

<br><br>

If <i class='arg'>pattern</i> is given, it's used as a <b class='cmd'>string match</b>
pattern; only names which match the pattern are returned.


<br><br>
<dt><a name="48"><b class='cmd'>$type</b> <strong>destroy</strong></a><dd>


Destroys the type's instances, the type's namespace, and the type
command itself.

This method is defined only for <b class='cmd'>snit::type</b>s; <b class='cmd'>snit::widget</b>s
use the Tk <b class='cmd'>destroy</b> command instead.

</dl>


<em>Components and Delegation</em>
<p>

When an object includes other objects, as when a toolbar contains
buttons or a GUI object contains an object that references a database,
the included object is called a component.  The standard way to handle
component objects owned by a Snit object is to assign their names to a
instance variable.  In the following example, a <b class='cmd'>dog</b> object has a
<b class='cmd'>tail</b> object:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::type dog {
        variable mytail
    
        constructor {args} {
            set mytail [tail %AUTO% -partof $self]
            $self configurelist $args
        }
    
        method wag {} {
            $mytail wag
        }
    }
    
    snit::type tail {
        option -length 5
        option -partof
        method wag {} { return &quot;Wag, wag, wag.&quot;}
    }
</pre></td></tr></table></p>
<p>

Because the <b class='cmd'>tail</b> object's name is stored in an instance
variable, it's easily accessible in any method.

<p>

As of Snit 0.84, the <b class='cmd'>install</b> command provides an alternate way
to create and install the component:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
snit::type dog {
    variable mytail

    constructor {args} {
        install mytail using tail %AUTO% -partof $self
        $self configurelist $args
    }

    method wag {} {
        $mytail wag
    }
}
</pre></td></tr></table></p>
<p>

For <b class='cmd'>snit::type</b>s, the two methods are equivalent; for
<b class='cmd'>snit::widget</b>s and <b class='cmd'>snit::widgetadaptor</b>s, the <b class='cmd'>install</b>
command properly initializes delegated options by querying
<em>the Tk option database</em>.

<p>

In the above examples, the <b class='cmd'>dog</b> object's <strong>wag</strong> method
simply calls the <b class='cmd'>tail</b> component's <strong>wag</strong> method.  In OO
circles, this is called delegation.  Snit provides an easier way to do
this, as shown:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::type dog {
        delegate method wag to mytail
    
        constructor {args} {
            set mytail [tail %AUTO% -partof $self]
            $self configurelist $args
        }
    }
</pre></td></tr></table></p>
<p>

The <b class='cmd'>delegate</b> statement in the type definition implicitly defines
the instance variable <strong>mytail</strong> to hold the component's name; it
also defines the <b class='cmd'>dog</b> object's <strong>wag</strong> method, delegating it
to the <strong>tail</strong> component.

<p>

If desired, all otherwise unknown methods can be delegated to a
specific component:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::type dog {
	delegate method * to mytail

	constructor {args} {
	    set mytail [tail %AUTO% -partof $self]
	    $self configurelist $args
	}

	method bark { return &quot;Bark, bark, bark!&quot; }
    }
</pre></td></tr></table></p>
<p>

In this case, a <b class='cmd'>dog</b> object will handle its own <strong>bark</strong>
method; but <strong>wag</strong> will be passed along to <b class='cmd'>mytail</b>.  Any
other method, being recognized by neither <b class='cmd'>dog</b> nor <b class='cmd'>tail</b>,
will simply raise an error.

<p>

Option delegation is similar to method delegation, except for the
interactions with the Tk option database; this is described in the
next section.


<em>The Tk Option Database</em>
<p>

This section describes how Snit interacts with the Tk option database,
and assumes the reader has a working knowledge of the option database
and its uses.  The book <em>Practical Programming in Tcl and Tk</em>
by Welch et al has a good introduction to the option database, as does
<em>Effective Tcl/Tk Programming</em>.

<p>

Snit is implemented so that most of the time it will simply do the
right thing with respect to the option database, provided that the
widget developer does the right thing by Snit.  The body of this
section goes into great deal about what Snit requires.  The following
is a brief statement of the requirements, for reference.

<p>

<ul>
<li>

If the widget's default widget class is not what is desired, set it
explicitly using <b class='cmd'>widgetclass</b> in the widget definition.

<br><br>
<li>

When defining or delegating options, specify the resource and class
names explicitly when necessary.

<br><br>
<li>

Use <b class='cmd'>installhull using</b> to install the hull for
<b class='cmd'>snit::widgetadaptor</b>s.

<br><br>
<li>

Use <b class='cmd'>install</b> to install all other components.

</ul>
<p>

The interaction of Tk widgets with the option database is a complex
thing; the interaction of Snit with the option database is even more
so, and repays attention to detail.

<p>

<em>Setting the widget class:</em> Every Tk widget has a widget class.
For Tk widgets, the widget class name is the just the widget type name
with an initial capital letter, e.g., the widget class for
<b class='cmd'>button</b> widgets is &quot;Button&quot;.

<p>

Similarly, the widget class of a <b class='cmd'>snit::widget</b> defaults to the
unqualified type name with the first letter capitalized.  For example,
the widget class of

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>snit::widget ::mylibrary::scrolledText { ... }</pre></td></tr></table></p>
<p>

is &quot;ScrolledText&quot;.  The widget class can also be set explicitly using
the <b class='cmd'>widgetclass</b> statement within the <b class='cmd'>snit::widget</b>
definition.

<p>

Note that only <b class='cmd'>frame</b> and <b class='cmd'>toplevel</b> widgets allow the user
to change the widget class name, which is why they are the allowable
hull types for normal <b class='cmd'>snit::widget</b>s.

<p>

The widget class of a <b class='cmd'>snit::widgetadaptor</b> is just the widget
class of its hull widget; this cannot be changed unless the hull
widget is a <b class='cmd'>frame</b> or <b class='cmd'>toplevel</b>, in which case it will
usually make more sense to use <b class='cmd'>snit::widget</b> rather than
<b class='cmd'>snit::widgetadaptor</b>.

<p>

<em>Setting option resource names and classes:</em> In Tk, every
option has three names: the option name, the resource name, and the
class name.  The option name begins with a hyphen is all lowercase;
it's used when creating widgets, and with the <b class='cmd'>configure</b> and
<b class='cmd'>cget</b> commands.

<p>

The resource and class names are used to initialize option default
values by querying the Tk option database.  The resource name is
usually just the option name minus the hyphen, but may contain
uppercase letters at word boundaries; the class name is usually just
the resource name with an initial capital, but not always.  For
example, here are the option, resource, and class names for several
<b class='cmd'>text</b> widget options:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    -background         background         Background 
    -borderwidth        borderWidth        BorderWidth 
    -insertborderwidth  insertBorderWidth  BorderWidth 
    -padx               padX               Pad 
</pre></td></tr></table></p>
<p>

As is easily seen, sometimes the resource and class names can be
inferred from the option name, but not always.

<p>

Snit options also have a resource name and a class name.  By default,
these names follow the rule given above: the resource name is the
option name without the hyphen, and the class name is the resource
name with an initial capital.  This is true for both locally-defined
options and explicitly delegated options:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::widget mywidget {
	option -background
	delegate option -borderwidth to hull
	delegate option * to text
	# ...
    }
</pre></td></tr></table></p>
<p>

In this case, the widget class name is &quot;Mywidget&quot;.  The widget has the
following options: -background, which is locally defined,
-borderwidth, which is explicitly delegated; all other widgets are
delegated to a component called &quot;text&quot;, which is probably a Tk

<b class='cmd'>text</b> widget.  If so, <b class='cmd'>mywidget</b> has all the same options as
a <b class='cmd'>text</b> widget.  The option, resource, and class names are as
follows:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    -background  background  Background
    -borderwidth borderwidth Borderwidth
    -padx        padX        Pad
</pre></td></tr></table></p>
<p>

Note that the locally defined option, &quot;-background&quot;, happens to have
the same three names as the standard Tk &quot;-background&quot; option; and
&quot;-pad&quot;, which is delegated implicitly to the &quot;text&quot; component has the
same three names for <b class='cmd'>mywidget</b> as it does for the <b class='cmd'>text</b>
widget.  &quot;-borderwidth&quot;, on the other hand, has different resource and
class names than usual, because the internal word &quot;width&quot; isn't
capitalized.  For consistency, it should be; this is done as shown:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::widget mywidget {
	option -background
	delegate option {-borderwidth borderWidth} to hull
	delegate option * to text
	# ...
    }
</pre></td></tr></table></p>
<p>

The class name will default to &quot;BorderWidth&quot;, as expected.

<p>

Suppose, however, that <b class='cmd'>mywidget</b> also delegated &quot;-padx&quot; and
&quot;-pady&quot; to the hull.  In this case, both the resource name and the
class name must be specified explicitly:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::widget mywidget {
	option -background
	delegate option {-borderwidth borderWidth} to hull
	delegate option {-padx padX Pad} to hull
	delegate option {-pady padY Pad} to hull
	delegate option * to text
	# ...
    }
</pre></td></tr></table></p>
<p>

<em>Querying the option database:</em> If you set your widgetclass and
option names as described above, Snit will query the option database
when each instance is created, and will generally do the right thing
when it comes to querying the option database.  The remainder of this
section goes into the gory details.

<p>

<em>Initializing locally defined options:</em>

When an instance of a snit::widget is created, its locally defined
options are initialized as follows: each option's resource and class
names are used to query the Tk option database.  If the result is
non-empty, it is used as the option's default; otherwise, the default
hardcoded in the type definition is used.  In either case, the default
can be overridden by the caller.  For example,

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    option add *Mywidget.texture pebbled

    snit::widget mywidget {
	option -texture smooth
	# ...
    }

    mywidget .mywidget -texture greasy
</pre></td></tr></table></p>
<p>

Here, &quot;-texture&quot; would normally default to &quot;smooth&quot;, but because of
the entry added to the option database it defaults to &quot;pebbled&quot;.
However, the caller has explicitly overridden the default, and so the
new widget will be &quot;greasy&quot;.

<p>

<em>Initializing options delegated to the hull:</em>

A <b class='cmd'>snit::widget</b>'s hull is a widget, and given that its class has
been set it is expected to query the option database for itself.  The
only exception concerns options that are delegated to it with a
different name.  Consider the following code:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    option add *Mywidget.borderWidth 5
    option add *Mywidget.relief sunken
    option add *Mywidget.hullbackground red
    option add *Mywidget.background green

    snit::widget mywidget {
	delegate option -borderwidth to hull
	delegate option -hullbackground to hull as -background
	delegate option * to hull
	# ...
    }

    mywidget .mywidget

    set A [.mywidget cget -relief]
    set B [.mywidget cget -hullbackground]
    set C [.mywidget cget -background]
    set D [.mywidget cget -borderwidth]
</pre></td></tr></table></p>
<p>

The question is, what are the values of variables A, B, C and D?

<p>

The value of A is &quot;sunken&quot;.  The hull is a Tk frame which has been
given the widget class &quot;Mywidget&quot;; it will automatically query the
option database and pick up this value.  Since the -relief option is
implicitly delegated to the hull, Snit takes no action.

<p>

The value of B is &quot;red&quot;.  The hull will automatically pick up the
value &quot;green&quot; for its -background option, just as it picked up the
-relief value.  However, Snit knows that -hullbackground is mapped to
the hull's -background option; hence, it queries the option database
for -hullbackground and gets &quot;red&quot; and updates the hull accordingly.

<p>

The value of C is also &quot;red&quot;, because -background is implicitly
delegated to the hull; thus, retrieving it is the same as retrieving
-hullbackground.  Note that this case is unusual; in practice,
-background would probably be explicitly delegated to some other
component.

<p>

The value of D is &quot;5&quot;, but not for the reason you think.  Note that as
it is defined above, the resource name for -borderwidth defaults to
&quot;borderwidth&quot;, whereas the option database entry is &quot;borderWidth&quot;.  As
with -relief, the hull picks up its own &quot;-borderwidth&quot; option before
Snit does anything.  Because the option is delegated under its own
name, Snit assumes that the correct thing has happened, and doesn't
worry about it any further.

<p>

For <b class='cmd'>snit::widgetadaptor</b>s, the case is somewhat altered.  Widget
adaptors retain the widget class of their hull, and the hull is not
created automatically by Snit.  Instead, the <b class='cmd'>snit::widgetadaptor</b>
must call <b class='cmd'>installhull</b> in its constructor.  The normal way to do
this is as follows:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::widgetadaptor mywidget {
	# ...
	constructor {args} {
	    # ...
	    installhull using text -foreground white
	    #
	}
	#...
    }
</pre></td></tr></table></p>
<p>

In this case, the <b class='cmd'>installhull</b> command will create the hull using
a command like this:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    set hull [text $win -foreground white]
</pre></td></tr></table></p>
<p>

The hull is a <b class='cmd'>text</b> widget, so its widget class is &quot;Text&quot;.  Just
as with <b class='cmd'>snit::widget</b> hulls, Snit assumes that it will pick up
all of its normal option values automatically; options delegated from
a different name are initialized from the option database in the same
way.

<p>

<em>Initializing options delegated to other components:</em>

Non-hull components are matched against the option database in two
ways.  First, a component widget remains a widget still, and therefore
is initialized from the option database in the usual way.

Second, the option database is queried for all options delegated to
the component, and the component is initialized accordingly--provided
that the <b class='cmd'>install</b> command is used to create it.

<p>

Before option database support was added to Snit, the usual way to
create a component was to simply create it in the constructor and
assign its command name to the component variable:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::widget mywidget {
	delegate option -background to myComp

	constructor {args} {
	    set myComp [text $win.text -foreground black]
	}
    }
</pre></td></tr></table></p>
<p>

The drawback of this method is that Snit has no opportunity to
initialize the component properly.  Hence, the following approach is
now used:

<p>
<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
    snit::widget mywidget {
	delegate option -background to myComp

	constructor {args} {
	    install myComp using text $win.text -foreground black
	}
    }
</pre></td></tr></table></p>
<p>

The <b class='cmd'>install</b> command does the following:

<p>
<ul>
<li>

Builds a list of the options explicitly included in the <b class='cmd'>install</b>
command -- in this case, -foreground.

<br><br>
<li>

Queries the option database for all options delegated explicitly to
the named component.

<br><br>
<li>

Creates the component using the specified command, after inserting
into it a list of options and values read from the option database.
Thus, the explicitly include options (-foreground) will override
anything read from the option database.

<br><br>
<li>

If the widget definition implicitly delegated options to the component
using &quot;delegate option *&quot;, then Snit calls the newly created
component's <b class='cmd'>configure</b> method to receive a list of all of the
component's options.  From this Snit builds a list of options
implicitly delegated to the component which were not explicitly
included in the <b class='cmd'>install</b> command.  For all such options, Snit
queries the option database and configures the component accordingly.

</ul>

<em>Non-widget components:</em> The option database is never queried
for <b class='cmd'>snit::type</b>s, since it can only be queried given a Tk widget
name.

However, <b class='cmd'>snit::widget</b>s can have non-widget components.  And if
options are delegated to those components, and if the <b class='cmd'>install</b>
command is used to install those components, then they will be
initialized from the option database just as widget components are.

<p>


<h2><a name="caveats">CAVEATS</a></h2>
<p>

Please understand that while Snit is already very stable, it is still
early days in Snit's development, and not be too critical. If you have
problems, find bugs, or new ideas you are hereby cordially invited to
submit a report of your problem, bug, or idea at the SourceForge
trackers for tcllib, which can be found at

<a href="http://sourceforge.net/projects/tcllib/">http://sourceforge.net/projects/tcllib/</a>.

The relevant category is <em>snit</em>.

<p>

One particular area to watch is the interaction of Snit with other
megawidget packages. Some widgets in BWidgets for example place their
own &lt;Destroy&gt; binding not on a separate bind-tag, but on the widget
itself. When used as the hull of a <b class='cmd'>snit::widgetadaptor</b> this
causes them to be called before Snit, removing the widget command. A
previous version of Snit was tripped by this and threw errors because
it tried to operate on and with an already deleted widget
command. Snit is now able to deal with this, despite the fact that the
ultimate cause is at least bad behaviour of Bwidget, possibly even a
bug. This however does not preclude that there might be other issues
lurking.

<p>

So, if you use a <b class='cmd'>snit::widgetadaptor</b> to adapt somebody else's
megawidget,

you need to be very careful about making sure the <b class='cmd'>bindtags</b> are
done properly.  There's no way for Snit to take into account all the
possible weird things other megawidget frameworks might do wrong.


<h2><a name="knownbugs">KNOWN BUGS</a></h2>
<p>

<ul>
<li>

Error stack traces returned by Snit are extremely ugly and typically
contain far too much information about Snit internals.

<br><br>
<li>

Also see the SourceForge Trackers at
<a href="http://sourceforge.net/projects/tcllib/">http://sourceforge.net/projects/tcllib/</a>, category <em>snit</em>.

</ul>


<h2><a name="history">HISTORY</a></h2>
<p>

During the course of developing Notebook

(See <a href="http://www.wjduquette.com/notebook">http://www.wjduquette.com/notebook</a>), my Tcl-based personal
notebook application, I found I was writing it as a collection of
objects.  I wasn't using any particular object-oriented framework; I
was just writing objects in pure Tcl following the guidelines in my
Guide to Object Commands

(See <a href="http://www.wjduquette.com/tcl/objects.html">http://www.wjduquette.com/tcl/objects.html</a>), along with a
few other tricks I'd picked up since.  And it was working very well.
But on the other hand, it was getting tiresome.  Writing objects in
pure Tcl is straightforward, once you figure it out, but there's a
fair amount of boilerplate code to write for each one, especially if
you're trying to create megawidgets or create objects with options,
like Tk widgets have.

<p>

So that was one thing--tedium is a powerful motivator.  But the other
thing I noticed is that I wasn't using inheritance at all, and I
wasn't missing it.  Instead, I was using delegation: objects that
created other objects and delegated methods to them.

<p>

And I said to myself, &quot;This is getting tedious...there has got to be a
better way.&quot;  And one afternoon, on a whim, I started working on Snit,
an object system that works the way Tcl works.  Snit doesn't support
inheritance, but it's great at delegation, and it makes creating
megawidgets easy.

<p>

I should add, I'm not particularly down on Incr Tcl.  But &quot;Snit's Not
Incr Tcl&quot; occurred to me while I was casting about for a name, and I
guess there was a certainly inevitability about it.

<p>

If you have any comments or suggestions (or bug reports!) don't
hesitate to send me e-mail at <a href="will@wjduquette.com">will@wjduquette.com</a>.  In addition,
there's now a Snit mailing list; you can find out more about it at the
Snit home page, see <a href="http://www.wjduquette.com/snit">http://www.wjduquette.com/snit</a>.

<p>


<h2><a name="credits">CREDITS</a></h2>
<p>

Snit has been designed and implemented from the very beginning by
William H. Duquette.  However, much credit belongs to the following
people for using Snit and providing me with valuable feedback: Rolf
Ade, Colin McCormack, Jose Nazario, Jeff Godfrey, Maurice Diamanti,
Egon Pasztor, David S. Cargo, Tom Krehbiel, and Michael Cleverly.




<h2><a name="keywords">KEYWORDS</a></h2>
<p>
BWidget, C++, Incr Tcl, adaptors, class, mega widget, object, object oriented, widget, widget adaptors
<h2><a name="copyright">COPYRIGHT</a></h2>
<p>
Copyright &copy; 2003, by William H. Duquette<br>
</body></html>
